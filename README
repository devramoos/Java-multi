# ‚òï Guia de Estudos: Linguagem Java  
**Estudante:** Rodrigo Ramos  
**Objetivo:** Reposit√≥rio pessoal e caderno de consultas t√©cnicas.

---

## üìå Sum√°rio
- [1. Vari√°veis e Tipos de Dados](#1-vari√°veis-e-tipos-de-dados)
  - [1.1. Dados Primitivos](#11-dados-primitivos)
  - [1.2. Dados N√£o Primitivos](#12-dados-n√£o-primitivos-objetos-e-refer√™ncias)
- [2. Estruturas de Controle e Repeti√ß√£o](#2-estruturas-de-controle-e-repeti√ß√£o)
  - [2.1. Loops](#21-estruturas-de-repeti√ß√£o-loops)
  - [2.2. Switch](#22-condicionais-switch)
- [3. Programa√ß√£o Orientada a Objetos (POO)](#3-programa√ß√£o-orientada-a-objetos-poo)
  - [3.1. Classes e M√©todos](#31-classes-e-m√©todos)
  - [3.2. Heran√ßa e Polimorfismo](#32-heran√ßa-e-polimorfismo-override)
  - [3.3. Interfaces e Classes Abstratas](#33-abstra√ß√£o-interfaces-e-classes-abstratas)
- [4. Conceitos Avan√ßados e Organiza√ß√£o](#4-conceitos-avan√ßados-e-organiza√ß√£o)
  - [4.1. Encapsulamento](#41-encapsulamento)
  - [4.2. Construtores e Enums](#42-construtores-e-enums)
  - [4.3. Refer√™ncia vs. Valor](#43-compara√ß√£o-refer√™ncia-vs-valor)
  - [4.4. Final](#44-modificador-final)
- [5. Novos Aprendizados](#5-novos-aprendizados-adicionados)
  - [5.1. main correto](#51-m√©todo-main-correto-ponto-de-entrada-do-programa)
  - [5.2. List / ArrayList / LinkedList](#52-cole√ß√µes-list-arraylist-e-linkedlist)
  - [5.3. Scanner sem bug do ENTER](#53-scanner-no-console-evitar-bug-do-enter)
  - [5.4. Interface na pr√°tica](#54-interface-na-pr√°tica-padronizar-listarremover)
  - [5.5. Heran√ßa aplicada](#55-heran√ßa-aplicada-classe-base)
  - [5.6. Enum aplicado](#56-enum-aplicado-padronizar-valores)
  - [5.7. Record](#57-record-estrutura-curta-para-carregar-dados)
  - [5.8. Remover item em lista](#58-remover-item-em-lista-l√≥gica-pr√°tica)

---

## 1. Vari√°veis e Tipos de Dados

### 1.1. Dados Primitivos
Os tipos primitivos armazenam valores simples diretamente na mem√≥ria.

```java
int idade = 22;                       // Inteiros
double altura = 1.75;                 // Decimais
boolean vivoOuMorto = true;           // true/false
long bilhao = 1_000_000_000L;         // Inteiros grandes
char letra = 'A';                     // Caractere √∫nico

1.2. Dados N√£o Primitivos (Objetos e Refer√™ncias)

Tipos que fazem refer√™ncia a objetos e possuem m√©todos pr√≥prios.

import java.util.ArrayList;
import java.util.Scanner;

String nome = "Rodrigo";               // String
int[] sequencia1 = new int[5];         // Array 1D
int[][] sequencia2 = new int[5][5];    // Array 2D

Scanner cdt = new Scanner(System.in);  // Entrada de dados

ArrayList<String> lista = new ArrayList<>();
lista.add("Java");

2. Estruturas de Controle e Repeti√ß√£o
2.1. Estruturas de Repeti√ß√£o (Loops)

While: verifica a condi√ß√£o antes de executar

For: ideal quando se sabe o n√∫mero de repeti√ß√µes

Do-While: executa pelo menos uma vez

// While
int i = 0;
while (i < 5) {
    System.out.println("i = " + i);
    i++;
}

// For
for (int j = 0; j <= 5; j++) {
    System.out.println("j = " + j);
}

// Do-While
int k = 0;
do {
    System.out.println("k = " + k);
    k++;
} while (k < 5);

2.2. Condicionais (Switch)

Ideal para m√∫ltiplas escolhas baseadas em uma √∫nica vari√°vel.

int opcao = 2;

switch (opcao) {
    case 1:
        System.out.println("Op√ß√£o 1 selecionada");
        break;
    case 2:
        System.out.println("Op√ß√£o 2 selecionada");
        break;
    default:
        System.out.println("Op√ß√£o inv√°lida");
        break;
}

3. Programa√ß√£o Orientada a Objetos (POO)
3.1. Classes e M√©todos

A base de qualquer aplica√ß√£o Java. M√©todos podem ou n√£o retornar valores.

public class Palavras {
    public void hello() {
        System.out.println("Hello");
    }

    public String helloComRetorno() {
        return "Hello!";
    }

    public int calcularDiferenca(int v1, int v2) {
        return v1 - v2;
    }
}

3.2. Heran√ßa e Polimorfismo (@Override)

Permite herdar atributos e comportamentos de outra classe, podendo sobrescrever m√©todos.

public class ResultadoDePalavras extends Palavras {
    @Override
    public void hello() {
        System.out.println("Hello people (Sobrescrito)");
    }
}

3.3. Abstra√ß√£o: Interfaces e Classes Abstratas

Interface: define um contrato (o que fazer)

Classe Abstrata: base que n√£o pode ser instanciada

public interface Valores {
    String getNomeFigura();
    int getArea();
}

public abstract class Animal {
    public abstract void som(); // M√©todo sem corpo, deve ser implementado pelas filhas
}

4. Conceitos Avan√ßados e Organiza√ß√£o
4.1. Encapsulamento

Prote√ß√£o de dados usando modificadores de acesso (private) e m√©todos Getters e Setters.

public class Conta {
    private double saldo;

    public double getSaldo() { return saldo; }
    public void setSaldo(double saldo) { this.saldo = saldo; }
}

4.2. Construtores e Enums
// Construtor: inicializa o objeto
public class Pessoa {
    String nome;
    public Pessoa(String nome) { this.nome = nome; }
}

// Enum: conjunto de constantes fixas
public enum Status { ATIVO, INATIVO }

4.3. Compara√ß√£o: Refer√™ncia vs. Valor

Objetos comparam refer√™ncia (endere√ßo). Use .equals() para comparar conte√∫do.

String s1 = new String("Java");
String s2 = new String("Java");

System.out.println(s1 == s2);      // false (refer√™ncias diferentes)
System.out.println(s1.equals(s2)); // true (conte√∫do igual)

4.4. Modificador Final

vari√°vel: constante

m√©todo: impede sobrescrita

classe: impede heran√ßa

final class Inalteravel {
    final int VALOR = 10;
}

5. Novos Aprendizados (adicionados)
5.1. M√©todo main correto (ponto de entrada do programa)

Para rodar no Java, o main precisa ser exatamente assim:

public class Main {
    public static void main(String[] args) {
        System.out.println("Rodando!");
    }
}

5.2. Cole√ß√µes: List, ArrayList e LinkedList

List √© a interface (contrato)

ArrayList e LinkedList s√£o implementa√ß√µes

import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

List<String> a1 = new ArrayList<>();
List<String> l1 = new LinkedList<>();

a1.add("Conta");
l1.add("Movimentacao");

5.3. Scanner no console (evitar bug do ENTER)

Forma simples: ler tudo com nextLine() e converter.

import java.util.Scanner;

Scanner sc = new Scanner(System.in);

System.out.print("Digite um numero: ");
int opcao = Integer.parseInt(sc.nextLine());

System.out.print("Digite um texto: ");
String nome = sc.nextLine();


Dica: esse padr√£o evita travar quando mistura n√∫mero + texto.

5.4. Interface na pr√°tica (padronizar listar/remover)

Contrato para qualquer item do sistema ter id() e linha():

public interface registravel {
    String id();
    String linha();
}

5.5. Heran√ßa aplicada (classe base)

Quando classes compartilham campos/m√©todos, cria-se uma classe base.

public abstract class itemBase implements registravel {
    protected String descricao;

    protected itemBase(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() { return descricao; }
}

5.6. Enum aplicado (padronizar valores)

Enums evitam texto solto e erro de digita√ß√£o.

public enum Grupo { RECEITA, DESPESA, CUSTO, IMPOSTO, OUTRO }
public enum Natureza { ENTRADA, SAIDA }

Grupo g = Grupo.RECEITA;
Natureza n = Natureza.SAIDA;

5.7. Record (estrutura curta para carregar dados)

record √© um pacote de dados pronto (construtor + getters + equals + toString).

public record cadastroConta(String codigo, String descricao) {}

cadastroConta dto = new cadastroConta("1.01", "Caixa");
System.out.println(dto.codigo());
System.out.println(dto.descricao());


Obs.: record n√£o herda de outras classes (√© √≥timo como DTO).

5.8. Remover item em lista (l√≥gica pr√°tica)

Remover pelo √≠ndice encontrado (mais confi√°vel):

import java.util.ArrayList;

ArrayList<String> lista = new ArrayList<>();
lista.add("A");
lista.add("B");
lista.add("C");

for (int i = 0; i < lista.size(); i++) {
    if (lista.get(i).equals("B")) {
        lista.remove(i);
        break;
    }
}
.
