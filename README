☕ Guia de Estudos: Linguagem Java
Estudante: Rodrigo Ramos
Objetivo: Repositório pessoal e caderno de consultas técnicas.
________________________________________
1. Variáveis e Tipos de Dados
1.1. Dados Primitivos
Os tipos primitivos são os blocos básicos de construção e armazenam valores simples diretamente na memória.
Java
int idade = 22;                       // Inteiros
double altura = 1.75;                 // Decimais de precisão dupla
boolean vivoOuMorto = true;           // Valores lógicos (true/false)
long bilhao = 1_000_000_000L;         // Inteiros de grande escala
char letra = 'A';                     // Único caractere
1.2. Dados Não Primitivos (Objetos e Referências)
Tipos que fazem referência a objetos e possuem métodos próprios.
Java
import java.util.ArrayList;
import java.util.Scanner;

String nome = "Rodrigo";               // Cadeia de caracteres
int[] sequencia1 = new int[5];         // Array unidimensional
int[][] sequencia2 = new int[5][5];    // Array bidimensional

// Entrada de dados e Coleções
Scanner cdt = new Scanner(System.in);
ArrayList<String> lista = new ArrayList<>();
lista.add("Java");
________________________________________
2. Estruturas de Controle e Repetição
2.1. Estruturas de Repetição (Loops)
Utilizadas para executar um bloco de código múltiplas vezes enquanto uma condição for verdadeira.
•	While: Verifica a condição antes de executar.
•	For: Ideal quando se sabe o número exato de repetições.
•	Do-While: Garante que o código seja executado pelo menos uma vez.
Java
// While
int i = 0;
while (i < 5) {
    System.out.println("i = " + i);
    i++;
}

// For
for (int j = 0; j <= 5; j++) {
    System.out.println("j = " + j);
}

// Do-While
int k = 0;
do {
    System.out.println("k = " + k);
    k++;
} while (k < 5);
2.2. Condicionais (Switch)
Ideal para múltiplas escolhas baseadas em uma única variável.
Java
int opcao = 2;
switch (opcao) {
    case 1:
        System.out.println("Opção 1 selecionada");
        break;
    case 2:
        System.out.println("Opção 2 selecionada");
        break;
    default:
        System.out.println("Opção inválida");
        break;
}
________________________________________
3. Programação Orientada a Objetos (POO)
3.1. Classes e Métodos
A base de qualquer aplicação Java. Métodos podem ou não retornar valores.
Java
public class Palavras {
    public void hello() {
        System.out.println("Hello");
    }
    
    public String helloComRetorno() {
        return "Hello!";
    }
    
    public int calcularDiferenca(int v1, int v2) {
        return v1 - v2;
    }
}
3.2. Herança e Polimorfismo (@Override)
Permite que uma classe herde atributos e comportamentos de outra, podendo sobrescrever métodos.
Java
public class ResultadoDePalavras extends Palavras {
    @Override
    public void hello() {
        System.out.println("Hello people (Sobrescrito)");
    }
}
3.3. Abstração: Interfaces e Classes Abstratas
•	Interface: Define um contrato (o que fazer).
•	Classe Abstrata: Uma "planta" que não pode ser instanciada, podendo conter métodos prontos ou abstratos.
Java
public interface Valores {
    String getNomeFigura();
    int getArea();
}

public abstract class Animal {
    public abstract void som(); // Método sem corpo, deve ser implementado pelas filhas
}
________________________________________
4. Conceitos Avançados e Organização
4.1. Encapsulamento
Proteção de dados usando modificadores de acesso (private) e métodos Getters e Setters.
Java
public class Conta {
    private double saldo;

    public double getSaldo() { return saldo; }
    public void setSaldo(double saldo) { this.saldo = saldo; }
}
4.2. Construtores e Enums
Java
// Construtor: Inicializa o objeto
public class Pessoa {
    String nome;
    public Pessoa(String nome) { this.nome = nome; }
}

// Enum: Conjunto de constantes fixas
public enum Status { ATIVO, INATIVO }
4.3. Comparação: Referência vs. Valor
Em Java, tipos primitivos comparam valores. Objetos comparam o endereço de memória (referência), por isso usamos .equals().
Java
String s1 = new String("Java");
String s2 = new String("Java");

System.out.println(s1 == s2);      // false (endereços diferentes)
System.out.println(s1.equals(s2)); // true (conteúdo igual)
4.4. Modificador Final
•	Variável: Torna-se uma constante.
•	Método: Impede que seja sobrescrito.
•	Classe: Impede que seja herdada.
Java
final class Inalteravel {
    final int VALOR = 10;}
